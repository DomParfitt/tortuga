@startuml

class FiniteStateMachine<T> {
    -Map<State, Set<AutomataAction<T>>> states
    +bool parse()
}

class State {
    - int number
    - bool isAccepting
}

interface AutomataAction<T> {
    +bool doAction(FiniteStateMachine<T>)
    +State getResultingState()
    +void setResultingState()
}


class LexerMachine<Character> {
    +LexerMachine(String)
}

class UnionFSM

class FollowedByFSM

abstract class PushdownAutomaton<T>

class Stack<T> {
    +T push()
    +T pop()
}

class Transition<T> {

}

abstract class StackAction<T> {
    -Stack stack
    +Stack getStack()
    +void setStack()
}

class StackPop<T> {
    -T expectedToken
    +T getExpectedToken()
    +void setExpectedToken()
}

FiniteStateMachine <|-- LexerMachine
FiniteStateMachine <|-- PushdownAutomaton

LexerMachine <|-- UnionFSM
LexerMachine <|-- FollowedByFSM

FiniteStateMachine -- "1*" State
FiniteStateMachine -- "*" AutomataAction

PushdownAutomaton <|-- ParserMachine
ParserMachine <|-- Push
ParserMachine <|-- Pop
ParserMachine <|-- Both
ParserMachine <|-- None

PushdownAutomaton -- "1" Stack

AutomataAction <|-- Transition
Transition <|-- StackAction
StackAction <-- StackPush
StackAction <-- StackPop
StackPop <-- StackPopAndPush

@enduml